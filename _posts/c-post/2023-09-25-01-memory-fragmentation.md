---
title: "[C/C++] 구조체의 메모리 단편화"
excerpt: ""

categories:
  - C
tags:
  - [C, Cpp]

last_modified_at: 2023-07-18
---

## 메모리 단편화

RAM의 메모리가 충분히 존재하지만, 할당이 불가능한 상태를 말합니다.   
메모리 단편화는 **내부 단편화**(Internal Fragmentation)와 **외부 단편화**(External Fragmentation)가 존재합니다.

### 내부 단편화

내부 단편화란 프로세스가 필요한 양 보다 더 큰 메모리가 할당되어 프로세스에서 사용하는 메모리가 낭비되는 상황입니다.

### 외부 단편화

메모리의 할당/해제 작업 반복 시 중간에 잔여 메모리가 생기는 현상으로,   
실제 총 메모리의 양은 충분하지만, 사용할 수 없는 상태를 말합니다.

## 구조체의 메모리 단편화

구조체를 정의 시 **내부 단편화**를 최소화 할 수 있습니다.

구조체는 기본적으로 내부 멤버 중 가장 큰 자료형의 크기를 기준으로 할당됩니다.

* 예시

  ```c
  typedef struct {
    int a = 1;
    char b = 'a';
  } Sample;
  ```

  * int → 4 바이트
  * char → 1 바이트

  총 5 바이트를 사용하는 구조체를 정의했지만, 실제 구조체의 크기는 8바이트를 할당합니다.   
  (가장 큰 자료형 int를 기준으로 크기가 할당되어 3바이트가 낭비된다고 볼 수 있습니다.)

### pragma pack

이러한 구조체의 메모리 단편화를 방지하는 방법으로 `#pragma pack`을 사용합니다.

```c
#pragma pack(push, n)
...
struct {
  ...
}
...
#pragma pack(pop)
```

* n값은 메모리를 정렬할 크기입니다 (1, 2, 4, 8, 16만 유효)

* 예시

  ```c
  #pragma pack(push, 1)
  typedef struct {
      int a = 1;
      char d = 'a';
  } Sample;
  #pragma pack(pop)
  ```

  * 메모리를 1씩 정렬하므로 위의 구조체는 5바이트만 할당됩니다.

